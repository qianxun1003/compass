# 单科匹配特殊情况处理方案

## 📋 一、问题描述

### 1.1 场景

**用户操作流程**：
1. 用户选择EJU科目组合：`rika-japanese-only`（日本語のみ）
2. 系统显示对应的输入框：`['日语', '托福']`
3. 用户填写成绩：只填写了日语（例如350分）
4. 系统匹配大学：某个大学只需要日语成绩（`ejuSubjects = "日语"`）

### 1.2 当前问题

**当前计算逻辑**：
```javascript
// 大学需要的科目：['日语']
// 用户成绩：日语 = 350分
// 参考分数：日语 = 320分（p50）

// 计算过程：
达成率 = 350 / 320 = 1.09
minRatio = min(1.09) = 1.09  // 只有一科，所以minRatio就是这一科的达成率
scoreEffect = 1.09
status = 'pass'  // 因为 >= 1.05
```

**问题点**：
1. **"短板原理"失效**：当只有一科时，`minRatio = min(所有科目)` 就是那一科的达成率，失去了"短板"的意义
2. **评判标准不统一**：
   - 多科匹配：需要所有科目都达到一定水平（短板原理）
   - 单科匹配：只需要这一科达到一定水平
   - 两者使用相同的评判标准（1.05 = 合格圏）是否公平？
3. **"完美匹配"概念缺失**：
   - 如果用户只考了日语，大学也只需要日语，这算不算"完美匹配"？
   - 是否应该有不同的显示方式或状态？

---

## 🎯 二、设计目标

1. **区分单科和多科匹配**：对单科匹配使用不同的评判标准
2. **公平性**：确保单科和多科匹配的评判标准在逻辑上一致
3. **用户友好**：明确标识"完美匹配"的情况
4. **向后兼容**：不影响现有的多科匹配逻辑

---

## 🔧 三、方案设计

### 方案A：单科匹配独立评判标准（推荐）

**核心思想**：单科匹配时，使用更严格的评判标准，因为"没有其他科目可以弥补"。

#### 3.1 评判标准调整

```javascript
function calculateMatchStatus(scoreEffect, requiredSubjectsCount) {
    // requiredSubjectsCount: 需要的科目数量（不包括托福，因为托福是单独判断的）
    const isSingleSubject = requiredSubjectsCount === 1;
    
    if (isSingleSubject) {
        // 单科匹配：使用更严格的标准
        if (scoreEffect >= 1.10) {
            return 'pass';      // ✅ 合格圏：超过参考分数10%以上
        } else if (scoreEffect >= 1.00 && scoreEffect < 1.10) {
            return 'close';    // ⚠️ 接近圏：在参考分数±10%范围内
        } else {
            return 'reach';     // 👀 观望圏：低于参考分数
        }
    } else {
        // 多科匹配：使用原有标准（短板原理）
        if (scoreEffect >= 1.05) {
            return 'pass';      // ✅ 合格圏：超过参考分数5%以上
        } else if (scoreEffect >= 0.95 && scoreEffect < 1.05) {
            return 'close';    // ⚠️ 接近圏：在参考分数±5%范围内
        } else {
            return 'reach';     // 👀 观望圏：低于参考分数5%以上
        }
    }
}
```

**理由**：
- 单科匹配时，没有其他科目可以"弥补"，所以要求更高
- 多科匹配时，即使某一科稍低，其他科目可以"拉高"整体水平

#### 3.2 完美匹配标识

```javascript
function calculateMatchStatusWithPerfect(scoreEffect, requiredSubjectsCount, userScores, thresholds) {
    const isSingleSubject = requiredSubjectsCount === 1;
    
    // 检查是否为"完美匹配"
    let isPerfectMatch = false;
    if (isSingleSubject) {
        // 单科匹配：如果达成率 >= 1.20（超过20%），视为"完美匹配"
        isPerfectMatch = scoreEffect >= 1.20;
    } else {
        // 多科匹配：如果所有科目达成率都 >= 1.10，视为"完美匹配"
        const allRatios = requiredSubjects.map(sub => {
            const userScore = getUserScoreForSubject(userScores, sub);
            const threshold = thresholds[sub];
            return threshold > 0 ? userScore / threshold : 0;
        });
        isPerfectMatch = allRatios.every(r => r >= 1.10);
    }
    
    let status = calculateMatchStatus(scoreEffect, requiredSubjectsCount);
    
    return {
        status: status,
        scoreEffect: scoreEffect,
        isPerfectMatch: isPerfectMatch,
        matchType: isSingleSubject ? 'single' : 'multiple'
    };
}
```

---

### 方案B：单科匹配使用"完美匹配"状态

**核心思想**：单科匹配时，如果用户只考了这一科，大学也只需要这一科，直接标记为"完美匹配"。

#### 3.1 完美匹配判断

```javascript
function checkPerfectMatch(uni, userScores, selectedEjuCategory) {
    const required = getRequiredSubjects(uni);
    const userEnteredSubjects = getEnteredSubjects(userScores);  // 用户实际填写的科目
    
    // 排除托福（因为托福是单独判断的）
    const requiredEju = required.filter(s => s !== '托福');
    const userEnteredEju = userEnteredSubjects.filter(s => s !== '托福');
    
    // 完美匹配条件：
    // 1. 大学只需要一科EJU科目
    // 2. 用户也只填写了这一科EJU科目
    // 3. 科目完全匹配
    const isPerfectMatch = 
        requiredEju.length === 1 && 
        userEnteredEju.length === 1 &&
        requiredEju[0] === userEnteredEju[0];
    
    if (isPerfectMatch) {
        return {
            status: 'perfect',  // 新增状态：完美匹配
            scoreEffect: calculateScoreEffect(uni, userScores),
            matchType: 'perfect-single'
        };
    }
    
    // 否则使用常规匹配逻辑
    return calculateMatchStatus(uni, userScores);
}
```

#### 3.2 显示逻辑

```javascript
function getStatusDisplay(status, isPerfectMatch) {
    if (isPerfectMatch || status === 'perfect') {
        return { 
            label: '完美匹配', 
            icon: '⭐', 
            color: 'gold',
            description: '科目完全匹配，无需其他科目'
        };
    }
    
    // 其他状态...
    switch (status) {
        case 'pass':
            return { label: '合格圏', icon: '✅', color: 'green', ... };
        case 'close':
            return { label: '接近圏', icon: '⚠️', color: 'yellow', ... };
        case 'reach':
            return { label: '观望圏', icon: '👀', color: 'orange', ... };
    }
}
```

---

### 方案C：单科匹配使用"直接匹配"概念

**核心思想**：单科匹配时，不计算"匹配度"，而是直接判断"是否满足要求"。

#### 3.1 直接匹配判断

```javascript
function calculateDirectMatch(uni, userScores) {
    const required = getRequiredSubjects(uni);
    const requiredEju = required.filter(s => s !== '托福');
    
    // 单科匹配：直接判断是否满足
    if (requiredEju.length === 1) {
        const subject = requiredEju[0];
        const userScore = getUserScoreForSubject(userScores, subject);
        const threshold = getThreshold(uni, subject);
        
        if (threshold <= 0) {
            return { status: 'unknown', scoreEffect: 0 };
        }
        
        const ratio = userScore / threshold;
        
        // 直接匹配：使用更直观的判断
        if (ratio >= 1.15) {
            return { status: 'excellent', scoreEffect: ratio };  // 优秀：超过15%
        } else if (ratio >= 1.05) {
            return { status: 'pass', scoreEffect: ratio };        // 合格：超过5%
        } else if (ratio >= 0.95) {
            return { status: 'close', scoreEffect: ratio };       // 接近：±5%
        } else {
            return { status: 'reach', scoreEffect: ratio };       // 观望：低于5%
        }
    }
    
    // 多科匹配：使用原有逻辑（短板原理）
    return calculateMultiSubjectMatch(uni, userScores);
}
```

---

## 📊 四、方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **方案A：独立评判标准** | 1. 逻辑清晰<br>2. 公平性好<br>3. 易于实现 | 1. 需要调整阈值<br>2. 用户可能需要理解两种标准 | 希望保持"匹配度"概念，但区分单科和多科 |
| **方案B：完美匹配状态** | 1. 用户友好<br>2. 直观易懂<br>3. 突出"完美匹配" | 1. 需要新增状态<br>2. 判断逻辑较复杂 | 希望明确标识"完美匹配"的情况 |
| **方案C：直接匹配** | 1. 简单直接<br>2. 不需要"匹配度"概念 | 1. 与现有逻辑差异大<br>2. 可能不够灵活 | 希望完全区分单科和多科的处理方式 |

---

## 🎨 五、推荐方案：混合方案（A + B）

结合方案A和方案B的优点：

### 5.1 核心逻辑

```javascript
function calculateMatchWithSpecialHandling(uni, userScores, selectedEjuCategory) {
    const required = getRequiredSubjects(uni);
    const requiredEju = required.filter(s => s !== '托福');
    const userEnteredSubjects = getEnteredSubjects(userScores);
    const userEnteredEju = userEnteredSubjects.filter(s => s !== '托福');
    
    const isSingleSubject = requiredEju.length === 1;
    const isPerfectMatch = 
        isSingleSubject && 
        userEnteredEju.length === 1 &&
        requiredEju[0] === userEnteredEju[0];
    
    // 计算匹配度
    const scoreEffect = calculateScoreEffect(uni, userScores);
    
    // 判断状态
    let status;
    if (isPerfectMatch && scoreEffect >= 1.20) {
        // 完美匹配：科目完全匹配 + 达成率 >= 1.20
        status = 'perfect';
    } else if (isSingleSubject) {
        // 单科匹配：使用更严格的标准
        if (scoreEffect >= 1.10) {
            status = 'pass';
        } else if (scoreEffect >= 1.00) {
            status = 'close';
        } else {
            status = 'reach';
        }
    } else {
        // 多科匹配：使用原有标准（短板原理）
        if (scoreEffect >= 1.05) {
            status = 'pass';
        } else if (scoreEffect >= 0.95) {
            status = 'close';
        } else {
            status = 'reach';
        }
    }
    
    return {
        status: status,
        scoreEffect: scoreEffect,
        isPerfectMatch: status === 'perfect',
        matchType: isPerfectMatch ? 'perfect-single' : (isSingleSubject ? 'single' : 'multiple'),
        requiredSubjectsCount: requiredEju.length
    };
}
```

### 5.2 显示逻辑

```javascript
function getStatusDisplay(matchResult) {
    const { status, isPerfectMatch, matchType } = matchResult;
    
    if (status === 'perfect' || isPerfectMatch) {
        return { 
            label: '完美匹配', 
            icon: '⭐', 
            color: 'gold',
            description: '科目完全匹配，成绩优秀',
            badge: '完美匹配'
        };
    }
    
    switch (status) {
        case 'pass':
            return { 
                label: '合格圏', 
                icon: '✅', 
                color: 'green',
                description: matchType === 'single' 
                    ? '超过参考分数10%以上（单科匹配）' 
                    : '超过参考分数5%以上（多科匹配）'
            };
        case 'close':
            return { 
                label: '接近圏', 
                icon: '⚠️', 
                color: 'yellow',
                description: matchType === 'single' 
                    ? '在参考分数±10%范围内（单科匹配）' 
                    : '在参考分数±5%范围内（多科匹配）'
            };
        case 'reach':
            return { 
                label: '观望圏', 
                icon: '👀', 
                color: 'orange',
                description: matchType === 'single' 
                    ? '低于参考分数（单科匹配）' 
                    : '低于参考分数5%以上（多科匹配）'
            };
    }
}
```

---

## 📈 六、示例计算

### 示例1：完美匹配

**场景**：
- 用户选择：`rika-japanese-only`（日本語のみ）
- 用户填写：日语 = 380分
- 大学：某大学，只需要日语（`ejuSubjects = "日语"`）
- 参考分数：日语 = 320分（p50）

**计算过程**：
1. **完美匹配检查**：
   - 大学需要：`['日语']`（1科）
   - 用户填写：`['日语']`（1科）
   - 科目匹配：✅
   - 达成率 = 380 / 320 = 1.19
   - 1.19 >= 1.20？❌ → 不满足完美匹配条件

2. **单科匹配判断**：
   - 达成率 = 1.19
   - 1.19 >= 1.10 → **合格圏**

**结果**：状态 = `pass`，匹配度 = 119%

---

### 示例2：真正的完美匹配

**场景**：
- 用户选择：`rika-japanese-only`（日本語のみ）
- 用户填写：日语 = 400分
- 大学：某大学，只需要日语（`ejuSubjects = "日语"`）
- 参考分数：日语 = 320分（p50）

**计算过程**：
1. **完美匹配检查**：
   - 大学需要：`['日语']`（1科）
   - 用户填写：`['日语']`（1科）
   - 科目匹配：✅
   - 达成率 = 400 / 320 = 1.25
   - 1.25 >= 1.20 → ✅ **完美匹配**

**结果**：状态 = `perfect`，匹配度 = 125%，显示"⭐ 完美匹配"

---

### 示例3：单科匹配但未达到完美

**场景**：
- 用户选择：`rika-japanese-only`（日本語のみ）
- 用户填写：日语 = 340分
- 大学：某大学，只需要日语（`ejuSubjects = "日语"`）
- 参考分数：日语 = 320分（p50）

**计算过程**：
1. **完美匹配检查**：
   - 达成率 = 340 / 320 = 1.06
   - 1.06 < 1.20 → ❌ 不满足完美匹配条件

2. **单科匹配判断**：
   - 达成率 = 1.06
   - 1.06 >= 1.00 && 1.06 < 1.10 → **接近圏**

**结果**：状态 = `close`，匹配度 = 106%

---

### 示例4：多科匹配（保持原逻辑）

**场景**：
- 用户选择：`bunka-full-3subjects`（日本語 + 総合 + 数学1）
- 用户填写：日语 = 350分，综合 = 180分，数学1 = 140分
- 大学：某大学，需要日语+综合+数学1（`ejuSubjects = "日语, 数学コース1, 綜合科目"`）
- 参考分数：日语 = 320分，综合 = 170分，数学1 = 130分

**计算过程**：
1. **多科匹配判断**：
   - 日语达成率 = 350 / 320 = 1.09
   - 综合达成率 = 180 / 170 = 1.06
   - 数学1达成率 = 140 / 130 = 1.08
   - minRatio = min(1.09, 1.06, 1.08) = 1.06
   - 1.06 >= 1.05 → **合格圏**

**结果**：状态 = `pass`，匹配度 = 106%（使用原有标准）

---

## 🔄 七、实现步骤

### 步骤1：添加辅助函数
- `getEnteredSubjects(userScores)`：获取用户实际填写的科目列表
- `checkPerfectMatch(uni, userScores)`：检查是否为完美匹配
- `calculateMatchWithSpecialHandling(uni, userScores)`：统一匹配计算入口

### 步骤2：修改匹配函数
- 在 `matchByScore()` 中集成新的匹配逻辑
- 区分单科和多科匹配的处理方式

### 步骤3：更新状态分类
- 添加 `perfect` 状态
- 更新状态显示逻辑

### 步骤4：更新UI显示
- 添加"完美匹配"的显示样式（金色、星星图标）
- 在结果中标注匹配类型（单科/多科/完美匹配）

### 步骤5：测试验证
- 测试单科匹配的各种情况
- 测试完美匹配的判断逻辑
- 测试多科匹配（确保向后兼容）

---

## 💡 八、方案优势

1. **逻辑清晰**：明确区分单科和多科匹配，使用不同的评判标准
2. **用户友好**：突出显示"完美匹配"的情况，让用户一目了然
3. **公平性**：单科匹配使用更严格的标准，符合"没有其他科目可以弥补"的逻辑
4. **向后兼容**：多科匹配保持原有逻辑，不影响现有功能
5. **灵活扩展**：易于添加新的匹配类型或调整评判标准

---

## ❓ 九、待讨论问题

1. **完美匹配阈值**：达成率 >= 1.20 是否合适？是否需要可配置？
2. **单科匹配阈值**：合格圏 >= 1.10，接近圏 >= 1.00 是否合适？
3. **显示方式**：完美匹配是否应该单独显示，还是与其他结果一起显示？
4. **托福处理**：托福是否应该参与"完美匹配"的判断？还是单独处理？
5. **用户提示**：是否需要在界面上提示用户"单科匹配使用更严格的标准"？

---

*最后更新：2025-02-12*
